
inductive UnaryOp : Type where
  | IsNum

inductive BinaryOp : Type where
  | Plus
  | Times

inductive Expr : Type where
  | Var (x : String)
  | Lit (i : Int)
  | Lam (f : String) (x : String) (e : Expr)
  | App (f : Expr) (arg : Expr)
  | Cons (head : Expr) (tails : Expr)
  | Let (x : String) (binds : Expr) (e : Expr)
  | If (condition : Expr) (branch‚ÇÄ : Expr) (branch‚ÇÅ : Expr)
  | Unary (op : UnaryOp) (e : Expr)
  | Binary (op : BinaryOp) (e‚ÇÄ : Expr) (e‚ÇÅ : Expr)
  | Lift (e : Expr)
  | Run (ctrl : Expr) (code : Expr)
  | Code (e : Expr)
  | Reflect (e : Expr)
  | Lamùïî (f : String) (x : String) (e : Expr)
  | Letùïî (x : String) (binds : Expr) (e : Expr)

inductive value : Expr -> Prop where
  | value_lit : value (.Lit i)
  | value_lam : value (.Lam f x e)
  | value_cons : value head -> value tails -> value (.Cons head tails)
  | value_code : value (.Code e)

inductive occur : String -> Expr -> Prop where
  | occur_var : occur x (.Var x)
  | occur_lam‚ÇÄ : occur f (.Lam f x e)
  | occur_lam‚ÇÅ : occur x (.Lam f x e)
  | occur_lam‚ÇÇ : occur x e -> occur x (.Lam f y e)
  | occur_app‚ÇÄ : occur x f -> occur x (.App f arg)
  | occur_app‚ÇÅ : occur x arg -> occur x (.App f arg)
  | occur_cons‚ÇÄ : occur x head -> occur x (.Cons head tails)
  | occur_cons‚ÇÅ : occur x tails -> occur x (.Cons head tails)
  | occur_let‚ÇÄ : occur x (.Let x binds e)
  | occur_let‚ÇÅ : occur x binds -> occur x (.Let y binds e)
  | occur_let‚ÇÇ : occur x e -> occur x (.Let y binds e)
  | occur_if‚ÇÄ : occur x condition -> occur x (.If condition branch‚ÇÄ branch‚ÇÅ)
  | occur_if‚ÇÅ : occur x branch‚ÇÄ -> occur x (.If condition branch‚ÇÄ branch‚ÇÅ)
  | occur_if‚ÇÇ : occur x branch‚ÇÅ -> occur x (.If condition branch‚ÇÄ branch‚ÇÅ)
  | occur_unary : occur x e -> occur x (.Unary op e)
  | occur_binary‚ÇÄ : occur x e‚ÇÄ -> occur x (.Binary op e‚ÇÄ e‚ÇÅ)
  | occur_binary‚ÇÅ : occur x e‚ÇÅ -> occur x (.Binary op e‚ÇÄ e‚ÇÅ)
  | occur_lift : occur x e -> occur x (.Lift e)
  | occur_run‚ÇÄ : occur x ctrl -> occur x (.Run ctrl code)
  | occur_run‚ÇÅ : occur x code -> occur x (.Run ctrl code)
  | occur_code : occur x e -> occur x (.Code e)
  | occur_reflect : occur x e -> occur x (.Reflect e)
  | occur_lamùïî‚ÇÄ : occur f (.Lamùïî f x e)
  | occur_lamùïî‚ÇÅ : occur x (.Lamùïî f x e)
  | occur_lamùïî‚ÇÇ : occur x e -> occur x (.Lamùïî f y e)
  | occur_letùïî‚ÇÄ : occur x (.Letùïî x binds e)
  | occur_letùïî‚ÇÅ : occur x binds -> occur x (.Letùïî y binds e)
  | occur_letùïî‚ÇÇ : occur x e -> occur x (.Letùïî y binds e)

abbrev Ctx :=
  Expr -> Expr

notation:max a "‚ü¶" b "‚üß" => a b

inductive occurŒì : String -> Ctx -> Prop where
  | occurŒì : ¬¨occur x e -> occur x Œì‚ü¶e‚üß -> occurŒì x Œì

inductive ctxùîπ : Ctx -> Prop where
  | ctxùîπ_consL : ctxùîπ (fun X => .Cons X tails)
  | ctxùîπ_consR : value v -> ctxùîπ (fun X => .Cons v X)
  | ctxùîπ_let : ctxùîπ (fun X => .Let x X e)
  | ctxùîπ_appL : ctxùîπ (fun X => .App X arg)
  | ctxùîπ_appR : value v -> ctxùîπ (fun X => .App v X)
  | ctxùîπ_if : ctxùîπ (fun X => .If X branch‚ÇÄ branch‚ÇÅ)
  | ctxùîπ_unary : ctxùîπ (fun X => .Unary op X)
  | ctxùîπ_binaryL : ctxùîπ (fun X => .Binary op X e‚ÇÅ)
  | ctxùîπ_binaryR : value v -> ctxùîπ (fun X => .Binary op v X)
  | ctxùîπ_lift : ctxùîπ (fun X => .Lift X)
  | ctxùîπ_run : ctxùîπ (fun X => .Run X code)

inductive ctx‚Ñù : Ctx -> Prop where
  | ctx‚Ñù_liftLamùïî : ctx‚Ñù (fun X => .Lift (.Lamùïî f x X))
  | ctx‚Ñù_ifL : ctx‚Ñù (fun X => .If (.Code condition) X branch‚ÇÅ)
  | ctx‚Ñù_ifR : value v -> ctx‚Ñù (fun X => .If (.Code condition) v X)
  | ctx‚Ñù_run : value v -> ctx‚Ñù (fun X => .Run v X)
  | ctx‚Ñù_Letùïî : ctx‚Ñù (fun X => .Letùïî x e X)

inductive ctxùïÑ : Ctx -> Prop where
  | ctxùïÑ_hole : ctxùïÑ (fun X => X)
  | ctxùïÑ_ùîπ : ctxùîπ B -> ctxùïÑ M -> ctxùïÑ (B ‚àò M)
  | ctxùïÑ_‚Ñù : ctx‚Ñù R -> ctxùïÑ M -> ctxùïÑ (R ‚àò M)

inductive ctxùîº : Ctx -> Prop where
  | ctxùîº_hole : ctxùîº (fun X => X)
  | ctxùîº_ùîπ : ctxùîπ B -> ctxùîº E -> ctxùîº (B ‚àò E)

mutual
  inductive ctx‚Ñô : Ctx -> Prop where
    | ctx‚Ñô_hole : ctx‚Ñô (fun X => X)
    | ctx‚Ñô_ùîπ : ctxùîπ B -> ctx‚Ñö Q -> ctx‚Ñô (B ‚àò Q)
    | ctx‚Ñô_‚Ñù : ctx‚Ñù R -> ctx‚Ñô P -> ctx‚Ñô (R ‚àò P)
  inductive ctx‚Ñö : Ctx -> Prop where
    | ctx‚Ñö_ùîπ : ctxùîπ B -> ctx‚Ñö Q -> ctx‚Ñö (B ‚àò Q)
    | ctx‚Ñö_‚Ñù : ctx‚Ñù R -> ctx‚Ñô P -> ctx‚Ñö (R ‚àò P)
end

def subst (x : String) (v : Expr) (e : Expr) : Expr :=
  match e with
  | .Var y => if x == y then v else .Var y
  | .Lit i => .Lit i
  | .Lam f y e => if x == f || x == y then .Lam f y e else .Lam f y (subst x v e)
  | .App f arg => .App (subst x v f) (subst x v arg)
  | .Cons head tails => .Cons (subst x v head) (subst x v tails)
  | .Let y binds e => if x == y then .Let y binds e else .Let y binds (subst x v e)
  | .If condition branch‚ÇÄ branch‚ÇÅ => .If (subst x v condition) (subst x v branch‚ÇÄ) (subst x v branch‚ÇÅ)
  | .Unary op e => .Unary op (subst x v e)
  | .Binary op e‚ÇÄ e‚ÇÅ => .Binary op (subst x v e‚ÇÄ) (subst x v e‚ÇÅ)
  | .Lift e => .Lift (subst x v e)
  | .Run ctrl code => .Run (subst x v ctrl) (subst x v code)
  | .Code e => .Code (subst x v e)
  | .Reflect e => .Reflect (subst x v e)
  | .Lamùïî f y e => if x == f || x == y then .Lamùïî f y e else .Lamùïî f y (subst x v e)
  | .Letùïî y binds e => if x == y then .Letùïî y binds e else .Letùïî y binds (subst x v e)

inductive step : Expr -> Expr -> Prop where
  | step_letŒ≤ : ctxùïÑ M -> value v -> step M‚ü¶.Let x v e‚üß M‚ü¶subst x v e‚üß
  | step_appŒ≤ : ctxùïÑ M -> value v -> step M‚ü¶.App (.Lam f x e) v‚üß M‚ü¶subst x v (subst f (.Lam f x e) e)‚üß
  | step_appùïî : ctxùïÑ M -> step M‚ü¶.App (.Code f) (.Code arg)‚üß M‚ü¶.Reflect (.App f arg)‚üß
  | step_ifnz : ctxùïÑ M -> n != 0 -> step M‚ü¶.If (.Lit n) branch‚ÇÄ branch‚ÇÅ‚üß M‚ü¶branch‚ÇÄ‚üß
  | step_ifz : ctxùïÑ M -> step M‚ü¶.If (.Lit 0) branch‚ÇÄ branch‚ÇÅ‚üß M‚ü¶branch‚ÇÅ‚üß
  |
  step_ifùïî :
    ctxùïÑ M -> step M‚ü¶.If (.Code condition) (.Code branch‚ÇÄ) (.Code branch‚ÇÅ)‚üß M‚ü¶.Reflect (.If condiction branch‚ÇÄ branch‚ÇÅ)‚üß
  | step_isNum : ctxùïÑ M -> value v -> v = .Lit n -> step M‚ü¶.Unary .IsNum v‚üß M‚ü¶(.Lit 1)‚üß
  | step_notNum‚ÇÄ : ctxùïÑ M -> value v -> v = .Lam f arg e -> step M‚ü¶.Unary .IsNum v‚üß M‚ü¶(.Lit 0)‚üß
  | step_notNum‚ÇÅ : ctxùïÑ M -> value v -> v = .Cons head tails -> step M‚ü¶.Unary .IsNum v‚üß M‚ü¶(.Lit 0)‚üß
  | step_isNumùïî : ctxùïÑ M -> step M‚ü¶.Unary .IsNum (.Code e)‚üß M‚ü¶(.Reflect (.Unary .IsNum e))‚üß
  | step_plus : ctxùïÑ M -> step M‚ü¶.Binary .Plus (.Lit n‚ÇÄ) (.Lit n‚ÇÅ)‚üß M‚ü¶.Lit (n‚ÇÄ + n‚ÇÅ)‚üß
  | step_times : ctxùïÑ M -> step M‚ü¶.Binary .Times (.Lit n‚ÇÄ) (.Lit n‚ÇÅ)‚üß M‚ü¶.Lit (n‚ÇÄ * n‚ÇÅ)‚üß
  | step_binaryùïî : ctxùïÑ M -> step M‚ü¶.Binary op (.Code e‚ÇÄ) (.Code e‚ÇÅ)‚üß M‚ü¶.Reflect (.Binary op e‚ÇÄ e‚ÇÅ)‚üß
  | step_lit : ctxùïÑ M -> step M‚ü¶.Lift (.Lit n)‚üß M‚ü¶.Code (.Lit n)‚üß
  | step_cons : ctxùïÑ M -> step M‚ü¶.Lift (.Cons (.Code head) (.Code tails))‚üß M‚ü¶.Reflect (.Cons head tails)‚üß
  |
  step_lam :
    ctxùïÑ M ->
      step M‚ü¶.Lift (.Lam f arg e)‚üß M‚ü¶.Lift (.Lamùïî f arg (subst arg (.Code (.Var arg)) (subst f (.Code (.Var f)) e)))‚üß
  | step_lamùïî : ctxùïÑ M -> step M‚ü¶.Lift (.Lamùïî f arg (.Code e))‚üß M‚ü¶.Reflect (.Lam f arg e)‚üß
  | step_code : ctxùïÑ M -> step M‚ü¶.Lift (.Code e)‚üß M‚ü¶.Reflect (.Lift e)‚üß
  | step_run‚ÇÄ : ctxùïÑ M -> value v -> v = .Lit _ -> step M‚ü¶.Run v (.Code code)‚üß M‚ü¶code‚üß
  | step_run‚ÇÅ : ctxùïÑ M -> value v -> v = .Lam _ _ _ -> step M‚ü¶.Run v (.Code code)‚üß M‚ü¶code‚üß
  | step_run‚ÇÇ : ctxùïÑ M -> value v -> v = .Cons _ _ -> step M‚ü¶.Run v (.Code code)‚üß M‚ü¶code‚üß
  | step_runùïî : ctxùïÑ M -> step M‚ü¶.Run (.Code ctrl) (.Code code)‚üß M‚ü¶.Reflect (.Run ctrl code)‚üß
  | step_reflect : ctx‚Ñô P -> ctxùîº E -> ¬¨occurŒì x E -> step P‚ü¶E‚ü¶.Reflect e‚üß‚üß P‚ü¶.Letùïî x e E‚ü¶.Code (.Var x)‚üß‚üß
  | step_letùïî : ctxùïÑ M -> step M‚ü¶.Letùïî x binds (.Code e)‚üß M‚ü¶.Code (.Let x binds e)‚üß

inductive mulit : Expr -> Expr -> Prop where
  | multi_stop : mulit e e
  | multi_step : step e‚ÇÄ e‚ÇÅ -> mulit e‚ÇÅ e‚ÇÇ -> mulit e‚ÇÄ e‚ÇÇ

theorem mulit_trans : mulit e‚ÇÄ e‚ÇÅ -> mulit e‚ÇÅ e‚ÇÇ -> mulit e‚ÇÄ e‚ÇÇ :=
  by
  intro me‚ÇÄe‚ÇÅ
  induction me‚ÇÄe‚ÇÅ with
  | multi_stop => simp
  | multi_step se‚ÇÄe‚ÇÉ _ ih =>
    intro me‚ÇÅe‚ÇÇ
    constructor
    apply se‚ÇÄe‚ÇÉ
    apply ih
    apply me‚ÇÅe‚ÇÇ

def expr‚ÇÄ : Expr :=
  .Lift (.Lam "f" "x" (.Binary .Plus (.Var "x") (.Binary .Times (.Var "x") (.Var "x"))))

def expr‚ÇÅ : Expr :=
  .Lift (.Lamùïî "f" "x" (.Binary .Plus (.Code (.Var "x")) (.Binary .Times (.Code (.Var "x")) (.Code (.Var "x")))))

def step‚ÇÄ : step expr‚ÇÄ expr‚ÇÅ := by
  rw [expr‚ÇÄ]
  rw [expr‚ÇÅ]
  apply (step.step_lam ctxùïÑ.ctxùïÑ_hole)

def expr‚ÇÇ : Expr :=
  .Lift (.Lamùïî "f" "x" (.Binary .Plus (.Code (.Var "x")) (.Reflect (.Binary .Times (.Var "x") (.Var "x")))))

def step‚ÇÅ : step expr‚ÇÅ expr‚ÇÇ := by
  rw [expr‚ÇÅ]
  rw [expr‚ÇÇ]
  apply
    (step.step_binaryùïî
      (ctxùïÑ.ctxùïÑ_‚Ñù ctx‚Ñù.ctx‚Ñù_liftLamùïî (ctxùïÑ.ctxùïÑ_ùîπ (ctxùîπ.ctxùîπ_binaryR value.value_code) (ctxùïÑ.ctxùïÑ_hole))))

def expr‚ÇÉ : Expr :=
  .Lift
    (.Lamùïî "f" "x"
      (.Letùïî "x‚ÇÅ" (.Binary .Times (.Var "x") (.Var "x")) (.Binary .Plus (.Code (.Var "x")) (.Code (.Var "x‚ÇÅ")))))

def step‚ÇÇ : step expr‚ÇÇ expr‚ÇÉ := by
  rw [expr‚ÇÇ]
  rw [expr‚ÇÉ]
  apply
    (step.step_reflect (ctx‚Ñô.ctx‚Ñô_‚Ñù ctx‚Ñù.ctx‚Ñù_liftLamùïî ctx‚Ñô.ctx‚Ñô_hole)
      (ctxùîº.ctxùîº_ùîπ (ctxùîπ.ctxùîπ_binaryR value.value_code) ctxùîº.ctxùîº_hole))
  intro hOccurŒì
  cases hOccurŒì with
  | occurŒì ihNotOccur ihOccur =>
    apply ihNotOccur
    simp at ihOccur
    cases ihOccur with
    | occur_binary‚ÇÄ ihOccur =>
      cases ihOccur with
      | occur_code ihOccur =>
        generalize eqx : "x" = x
        generalize eqx‚ÇÅ : "x‚ÇÅ" = x‚ÇÅ
        rw [eqx, eqx‚ÇÅ] at ihOccur
        cases ihOccur
        rw [‚Üê eqx] at eqx‚ÇÅ
        contradiction
    | occur_binary‚ÇÅ ihOccur => apply ihOccur

def expr‚ÇÑ : Expr :=
  .Lift
    (.Lamùïî "f" "x"
      (.Letùïî "x‚ÇÅ" (.Binary .Times (.Var "x") (.Var "x")) (.Reflect (.Binary .Plus (.Var "x") (.Var "x‚ÇÅ")))))

def step‚ÇÉ : step expr‚ÇÉ expr‚ÇÑ := by
  rw [expr‚ÇÉ]
  rw [expr‚ÇÑ]
  apply (step.step_binaryùïî (ctxùïÑ.ctxùïÑ_‚Ñù ctx‚Ñù.ctx‚Ñù_liftLamùïî (ctxùïÑ.ctxùïÑ_‚Ñù (ctx‚Ñù.ctx‚Ñù_Letùïî) (ctxùïÑ.ctxùïÑ_hole))))

def expr‚ÇÖ : Expr :=
  .Lift
    (.Lamùïî "f" "x"
      (.Letùïî "x‚ÇÅ" (.Binary .Times (.Var "x") (.Var "x"))
        (.Letùïî "x‚ÇÇ" (.Binary .Plus (.Var "x") (.Var "x‚ÇÅ")) (.Code (.Var "x‚ÇÇ")))))

def step‚ÇÑ : step expr‚ÇÑ expr‚ÇÖ := by
  rw [expr‚ÇÑ]
  rw [expr‚ÇÖ]
  apply
    (step.step_reflect (ctx‚Ñô.ctx‚Ñô_‚Ñù ctx‚Ñù.ctx‚Ñù_liftLamùïî (ctx‚Ñô.ctx‚Ñô_‚Ñù ctx‚Ñù.ctx‚Ñù_Letùïî ctx‚Ñô.ctx‚Ñô_hole)) (ctxùîº.ctxùîº_hole))
  intro hOccurŒì
  cases hOccurŒì with
  | occurŒì ihNotOccur ihOccur =>
    apply ihNotOccur
    simp at ihOccur
    apply ihOccur

def expr‚ÇÜ : Expr :=
  .Lift
    (.Lamùïî "f" "x"
      (.Letùïî "x‚ÇÅ" (.Binary .Times (.Var "x") (.Var "x"))
        (.Code (.Let "x‚ÇÇ" (.Binary .Plus (.Var "x") (.Var "x‚ÇÅ")) (.Var "x‚ÇÇ")))))

def step‚ÇÖ : step expr‚ÇÖ expr‚ÇÜ := by
  rw [expr‚ÇÖ]
  rw [expr‚ÇÜ]
  apply (step.step_letùïî (ctxùïÑ.ctxùïÑ_‚Ñù ctx‚Ñù.ctx‚Ñù_liftLamùïî (ctxùïÑ.ctxùïÑ_‚Ñù (ctx‚Ñù.ctx‚Ñù_Letùïî) (ctxùïÑ.ctxùïÑ_hole))))

def expr‚Çá : Expr :=
  .Lift
    (.Lamùïî "f" "x"
      (.Code
        (.Let "x‚ÇÅ" (.Binary .Times (.Var "x") (.Var "x"))
          (.Let "x‚ÇÇ" (.Binary .Plus (.Var "x") (.Var "x‚ÇÅ")) (.Var "x‚ÇÇ")))))

def step‚ÇÜ : step expr‚ÇÜ expr‚Çá := by
  rw [expr‚ÇÜ]
  rw [expr‚Çá]
  apply (step.step_letùïî (ctxùïÑ.ctxùïÑ_‚Ñù ctx‚Ñù.ctx‚Ñù_liftLamùïî ctxùïÑ.ctxùïÑ_hole))

def expr‚Çà : Expr :=
  .Reflect
    (.Lam "f" "x"
      (.Let "x‚ÇÅ" (.Binary .Times (.Var "x") (.Var "x")) (.Let "x‚ÇÇ" (.Binary .Plus (.Var "x") (.Var "x‚ÇÅ")) (.Var "x‚ÇÇ"))))

def step‚Çá : step expr‚Çá expr‚Çà := by
  rw [expr‚Çá]
  rw [expr‚Çà]
  apply (step.step_lamùïî ctxùïÑ.ctxùïÑ_hole)

def expr‚Çâ : Expr :=
  .Letùïî "x‚ÇÉ"
    (.Lam "f" "x"
      (.Let "x‚ÇÅ" (.Binary .Times (.Var "x") (.Var "x")) (.Let "x‚ÇÇ" (.Binary .Plus (.Var "x") (.Var "x‚ÇÅ")) (.Var "x‚ÇÇ"))))
    (.Code (.Var "x‚ÇÉ"))

def step‚Çà : step expr‚Çà expr‚Çâ := by
  rw [expr‚Çà]
  rw [expr‚Çâ]
  apply (step.step_reflect ctx‚Ñô.ctx‚Ñô_hole ctxùîº.ctxùîº_hole)
  intro hOccurŒì
  cases hOccurŒì with
  | occurŒì ihNotOccur ihOccur =>
    apply ihNotOccur
    simp at ihOccur
    apply ihOccur

def expr‚Çì : Expr :=
  .Code
    (.Let "x‚ÇÉ"
      (.Lam "f" "x"
        (.Let "x‚ÇÅ" (.Binary .Times (.Var "x") (.Var "x"))
          (.Let "x‚ÇÇ" (.Binary .Plus (.Var "x") (.Var "x‚ÇÅ")) (.Var "x‚ÇÇ"))))
      (.Var "x‚ÇÉ"))

def step‚Çâ : step expr‚Çâ expr‚Çì := by
  rw [expr‚Çâ]
  rw [expr‚Çì]
  apply (step.step_letùïî ctxùïÑ.ctxùïÑ_hole)

theorem eval_expr‚ÇÄ : mulit expr‚ÇÄ expr‚Çì := by
  constructor
  apply step‚ÇÄ
  constructor
  apply step‚ÇÅ
  constructor
  apply step‚ÇÇ
  constructor
  apply step‚ÇÉ
  constructor
  apply step‚ÇÑ
  constructor
  apply step‚ÇÖ
  constructor
  apply step‚ÇÜ
  constructor
  apply step‚Çá
  constructor
  apply step‚Çà
  constructor
  apply step‚Çâ
  constructor

import CollapsingTowers.TwoLvLBasic.SyntacticTyping.Defs

mutual
-- ùì•‚ü¶‚Ñï‚üß ‚âú {(n, n) | n ‚àà ‚Ñï}
-- ùì•‚ü¶œÑùïí ‚Üí œÑùïì‚üß ‚âú {(Œª.e‚ÇÄ, Œª.e‚ÇÅ) | ‚àÄ (v‚ÇÄ, v‚ÇÅ) ‚àà ùì•‚ü¶œÑùïí‚üß. (e‚ÇÄ‚ü¶0 ‚Ü¶ v‚ÇÄ‚üß, e‚ÇÅ‚ü¶0 ‚Ü¶ v‚ÇÅ‚üß) ‚àà ùìî‚ü¶œÑùïì‚üß}
@[simp]
def logic_equiv_value : Expr ‚Üí Expr ‚Üí Ty ‚Üí Prop
  | .lit n‚ÇÄ, .lit n‚ÇÅ, .nat => n‚ÇÄ = n‚ÇÅ
  | .lam e‚ÇÄ, .lam e‚ÇÅ, (.arrow œÑùïí œÑùïì .pure) =>
      wf (.lam e‚ÇÄ) ‚àß
      wf (.lam e‚ÇÅ) ‚àß
      ‚àÄ v‚ÇÄ v‚ÇÅ,
        logic_equiv_value v‚ÇÄ v‚ÇÅ œÑùïí ‚Üí
        logic_equiv_expr (opening 0 v‚ÇÄ e‚ÇÄ) (opening 0 v‚ÇÅ e‚ÇÅ) œÑùïì
  | _, _, _ => false

-- ùìî‚ü¶œÑ‚üß ‚âú {(e‚ÇÄ, e‚ÇÅ) | ‚àÉv‚ÇÄ v‚ÇÅ. e‚ÇÄ ‚áæ* v‚ÇÄ ‚àß e‚ÇÅ ‚áæ* v‚ÇÅ ‚àß (v‚ÇÄ, v‚ÇÅ) ‚àà ùì•‚ü¶œÑ‚üß}
@[simp]
def logic_equiv_expr (e‚ÇÄ : Expr) (e‚ÇÅ : Expr) (œÑ : Ty) : Prop :=
    ‚àÉ v‚ÇÄ v‚ÇÅ,
      (e‚ÇÄ ‚áæ* v‚ÇÄ) ‚àß
      (e‚ÇÅ ‚áæ* v‚ÇÅ) ‚àß
      logic_equiv_value v‚ÇÄ v‚ÇÅ œÑ
end

inductive logic_equiv_env : Subst ‚Üí Subst ‚Üí TEnv ‚Üí Prop where
  | nil : logic_equiv_env [] [] []
  | cons :
    ‚àÄ v‚ÇÄ Œ≥‚ÇÄ v‚ÇÅ Œ≥‚ÇÅ œÑ Œì,
      logic_equiv_value v‚ÇÄ v‚ÇÅ œÑ ‚Üí
      logic_equiv_env Œ≥‚ÇÄ Œ≥‚ÇÅ Œì ‚Üí
      logic_equiv_env (v‚ÇÄ :: Œ≥‚ÇÄ) (v‚ÇÅ :: Œ≥‚ÇÅ) ((œÑ, ùüô) :: Œì)

-- Œì ‚äß e‚ÇÄ ‚âà e‚ÇÅ : œÑ ‚âú ‚àÄ (Œ≥‚ÇÄ, Œ≥‚ÇÅ) ‚àà ùìñ‚ü¶Œì‚üß. (Œ≥‚ÇÄ(e‚ÇÄ), Œ≥‚ÇÅ(e‚ÇÅ)) ‚àà ùìî‚ü¶œÑ‚üß
@[simp]
def logic_equiv_typing (Œì : TEnv) (e‚ÇÄ : Expr) (e‚ÇÅ : Expr) (œÑ : Ty) : Prop :=
  wf_at e‚ÇÄ Œì.length ‚àß
  wf_at e‚ÇÅ Œì.length ‚àß
  ‚àÄ Œ≥‚ÇÄ Œ≥‚ÇÅ,
    logic_equiv_env Œ≥‚ÇÄ Œ≥‚ÇÅ Œì ‚Üí
    logic_equiv_expr (multi_subst Œ≥‚ÇÄ e‚ÇÄ) (multi_subst Œ≥‚ÇÅ e‚ÇÅ) œÑ

lemma logic_equiv_value.syntactic_value :
  ‚àÄ v‚ÇÄ v‚ÇÅ œÑ,
    logic_equiv_value v‚ÇÄ v‚ÇÅ œÑ ‚Üí
    value v‚ÇÄ ‚àß value v‚ÇÅ :=
  by
  intros v‚ÇÄ v‚ÇÅ œÑ Hsem_value
  cases œÑ
  case nat =>
    cases v‚ÇÄ <;> cases v‚ÇÅ <;> simp at Hsem_value
    constructor
    apply value.lit
    apply value.lit
  case arrow œÜ =>
    cases v‚ÇÄ <;> cases v‚ÇÅ <;> cases œÜ <;> simp at Hsem_value
    have ‚ü®Hwf‚ÇÄ, Hwf‚ÇÅ, _‚ü© := Hsem_value
    constructor
    apply value.lam; apply Hwf‚ÇÄ.left
    apply value.lam; apply Hwf‚ÇÅ.left
  all_goals simp at Hsem_value

lemma logic_equiv_value.wf :
  ‚àÄ v‚ÇÄ v‚ÇÅ œÑ,
    logic_equiv_value v‚ÇÄ v‚ÇÅ œÑ ‚Üí
    wf v‚ÇÄ ‚àß
    wf v‚ÇÅ :=
  by
  intros v‚ÇÄ v‚ÇÅ œÑ Hsem_value
  cases œÑ
  case nat =>
    cases v‚ÇÄ <;> cases v‚ÇÅ <;> simp at Hsem_value
    repeat constructor
  case arrow œÜ =>
    cases v‚ÇÄ <;> cases v‚ÇÅ <;> cases œÜ <;> simp at Hsem_value
    have ‚ü®Hwf‚ÇÄ, Hwf‚ÇÅ, _‚ü© := Hsem_value
    constructor
    apply Hwf‚ÇÄ; apply Hwf‚ÇÅ
  all_goals simp at Hsem_value

lemma logic_equiv_env.multi_wf :
  ‚àÄ Œ≥‚ÇÄ Œ≥‚ÇÅ Œì,
    logic_equiv_env Œ≥‚ÇÄ Œ≥‚ÇÅ Œì ‚Üí
    multi_wf Œ≥‚ÇÄ ‚àß
    multi_wf Œ≥‚ÇÅ :=
  by
  intros Œ≥‚ÇÄ Œ≥‚ÇÅ Œì H
  induction H
  case nil => repeat constructor
  case cons Hsem_value _ IH =>
    constructor
    . constructor; apply And.left
      apply logic_equiv_value.wf
      apply Hsem_value; apply IH.left
    . constructor; apply And.right
      apply logic_equiv_value.wf
      apply Hsem_value; apply IH.right

lemma logic_equiv_env.length :
  ‚àÄ Œ≥‚ÇÄ Œ≥‚ÇÅ Œì,
    logic_equiv_env Œ≥‚ÇÄ Œ≥‚ÇÅ Œì ‚Üí
    Œ≥‚ÇÄ.length = Œì.length ‚àß
    Œ≥‚ÇÅ.length = Œì.length :=
  by
  intros Œ≥‚ÇÄ Œ≥‚ÇÅ Œì H
  induction H
  case nil => simp
  case cons IH =>
    constructor
    . simp; apply IH.left
    . simp; apply IH.right

lemma logic_equiv_env.binds_logic_equiv_value :
  ‚àÄ Œ≥‚ÇÄ Œ≥‚ÇÅ Œì x œÑ,
    logic_equiv_env Œ≥‚ÇÄ Œ≥‚ÇÅ Œì ‚Üí
    binds x (œÑ, .stat) Œì ‚Üí
    logic_equiv_value (multi_subst Œ≥‚ÇÄ (.fvar x)) (multi_subst Œ≥‚ÇÅ (.fvar x)) œÑ :=
  by
  intros Œ≥‚ÇÄ Œ≥‚ÇÅ Œì x œÑ HsemŒì Hbinds
  induction HsemŒì
  case nil => nomatch Hbinds
  case cons v‚ÇÄ Œ≥‚ÇÄ v‚ÇÅ Œ≥‚ÇÅ œÑ Œì Hsem_value HsemŒì IH =>
    have ‚ü®Hwf‚ÇÄ, Hwf‚ÇÅ‚ü© := logic_equiv_value.wf _ _ _ Hsem_value
    have ‚ü®HEq‚ÇÄ, HEq‚ÇÅ‚ü© := logic_equiv_env.length _ _ _ HsemŒì
    simp [HEq‚ÇÄ, HEq‚ÇÅ]
    by_cases HEqx : Œì.length = x
    . simp [if_pos HEqx]
      simp [if_pos HEqx] at Hbinds
      rw [‚Üê Hbinds, identity.multi_subst, identity.multi_subst]
      apply Hsem_value; apply Hwf‚ÇÅ.right; apply Hwf‚ÇÄ.right
    . simp [if_neg HEqx]
      simp [if_neg HEqx] at Hbinds
      apply IH; apply Hbinds

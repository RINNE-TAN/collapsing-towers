import Mathlib.Data.Set.Insert
import CollapsingTowers.TwoLevelMut.Syntax.Transform

@[simp]
def fv : Expr ‚Üí Set ‚Ñï
  | .bvar _ => ‚àÖ
  | .fvar x => { x }
  | .lam e => fv e
  | .lift e => fv e
  | .app‚ÇÅ f arg => fv f ‚à™ fv arg
  | .app‚ÇÇ f arg => fv f ‚à™ fv arg
  | .lit _ => ‚àÖ
  | .run e => fv e
  | .code e => fv e
  | .reflect e => fv e
  | .lamùïî e => fv e
  | .lets b e => fv b ‚à™ fv e
  | .letsùïî b e => fv b ‚à™ fv e
  | .unit => ‚àÖ
  | .loc _ => ‚àÖ
  | .alloc‚ÇÅ e => fv e
  | .alloc‚ÇÇ e => fv e
  | .load‚ÇÅ e => fv e
  | .load‚ÇÇ e => fv e
  | .store‚ÇÅ l r => fv l ‚à™ fv r
  | .store‚ÇÇ l r => fv l ‚à™ fv r

lemma fv.under_opening : ‚àÄ i v e, fv (opening i v e) ‚äÜ fv v ‚à™ fv e :=
  by
  intros i v e
  induction e generalizing i with
  | bvar j =>
    simp; by_cases HEq : j = i
    . rw [if_pos HEq]
    . rw [if_neg HEq]; simp
  | fvar z => simp
  | lit| unit| loc => simp
  | lam _ IH
  | lift _ IH
  | lamùïî _ IH
  | code _ IH
  | reflect _ IH
  | run _ IH
  | alloc‚ÇÅ _ IH
  | alloc‚ÇÇ _ IH
  | load‚ÇÅ _ IH
  | load‚ÇÇ _ IH =>
    apply IH
  | app‚ÇÅ _ _ IH‚ÇÄ IH‚ÇÅ
  | app‚ÇÇ _ _ IH‚ÇÄ IH‚ÇÅ
  | lets _ _ IH‚ÇÄ IH‚ÇÅ
  | letsùïî _ _ IH‚ÇÄ IH‚ÇÅ
  | store‚ÇÅ _ _ IH‚ÇÄ IH‚ÇÅ
  | store‚ÇÇ _ _ IH‚ÇÄ IH‚ÇÅ =>
    simp; constructor
    . apply Set.Subset.trans; apply IH‚ÇÄ
      apply Set.union_subset_union; rfl; simp
    . apply Set.Subset.trans; apply IH‚ÇÅ
      apply Set.union_subset_union; rfl; simp

lemma fv.under_closing : ‚àÄ i x e, fv (closing i x e) = fv e \ { x } :=
  by
  intros i x e
  induction e generalizing i with
  | bvar => simp
  | fvar y =>
    by_cases HEq : x = y
    . simp [if_pos HEq]
      simp [HEq]
    . simp [if_neg HEq]
      rw [Set.diff_singleton_eq_self]
      simp; apply HEq
  | lit| unit| loc => simp
  | lam _ IH
  | lift _ IH
  | lamùïî _ IH
  | code _ IH
  | reflect _ IH
  | run _ IH
  | alloc‚ÇÅ _ IH
  | alloc‚ÇÇ _ IH
  | load‚ÇÅ _ IH
  | load‚ÇÇ _ IH =>
    apply IH
  | app‚ÇÅ _ _ IH‚ÇÄ IH‚ÇÅ
  | app‚ÇÇ _ _ IH‚ÇÄ IH‚ÇÅ
  | lets _ _ IH‚ÇÄ IH‚ÇÅ
  | letsùïî _ _ IH‚ÇÄ IH‚ÇÅ
  | store‚ÇÅ _ _ IH‚ÇÄ IH‚ÇÅ
  | store‚ÇÇ _ _ IH‚ÇÄ IH‚ÇÅ =>
    simp [IH‚ÇÄ, IH‚ÇÅ]
    rw [Set.union_diff_distrib]

lemma fv.under_codify : ‚àÄ e i, fv e = fv (codify i e) :=
  by
  intros e i
  induction e generalizing i with
  | bvar j =>
    by_cases HEq : j = i
    . simp [if_pos HEq]
    . simp [if_neg HEq]
  | fvar => rfl
  | lit| unit| loc => rfl
  | lam _ IH
  | lift _ IH
  | lamùïî _ IH
  | code _ IH
  | reflect _ IH
  | run _ IH
  | alloc‚ÇÅ _ IH
  | alloc‚ÇÇ _ IH
  | load‚ÇÅ _ IH
  | load‚ÇÇ _ IH =>
    apply IH
  | app‚ÇÅ _ _ IH‚ÇÄ IH‚ÇÅ
  | app‚ÇÇ _ _ IH‚ÇÄ IH‚ÇÅ
  | lets _ _ IH‚ÇÄ IH‚ÇÅ
  | letsùïî _ _ IH‚ÇÄ IH‚ÇÅ
  | store‚ÇÅ _ _ IH‚ÇÄ IH‚ÇÅ
  | store‚ÇÇ _ _ IH‚ÇÄ IH‚ÇÅ =>
    simp; rw [IH‚ÇÄ, IH‚ÇÅ]

lemma not_in_fv.under_opening :
  ‚àÄ x y i e,
    x ‚àâ fv e ‚Üí
    x ‚â† y ‚Üí
    x ‚àâ fv ({i ‚Ü¶ y} e) :=
  by
  intros x y i e HNotIn HNe HIn
  apply HNotIn
  have H : fv ({i ‚Ü¶ y} e) ‚äÜ { y } ‚à™ fv e := by apply fv.under_opening
  rw [Set.subset_def] at H
  cases (H x HIn)
  case inl => simp at *; omega
  case inr => assumption

lemma not_in_fv.under_subst :
  ‚àÄ x e v,
    x ‚àâ fv v ‚Üí
    x ‚àâ fv (subst x v e) :=
  by
  intros x e v HNotIn HIn
  apply HNotIn
  induction e with
  | bvar j => nomatch HIn
  | fvar y =>
    by_cases HEq : x = y
    . simp [if_pos HEq] at HIn
      apply HIn
    . simp [if_neg HEq] at HIn
      contradiction
  | lit| unit| loc =>
    nomatch HIn
  | lam _ IH
  | lift _ IH
  | lamùïî _ IH
  | code _ IH
  | reflect _ IH
  | run _ IH
  | alloc‚ÇÅ _ IH
  | alloc‚ÇÇ _ IH
  | load‚ÇÅ _ IH
  | load‚ÇÇ _ IH =>
    apply IH; apply HIn
  | app‚ÇÅ _ _ IH‚ÇÄ IH‚ÇÅ
  | app‚ÇÇ _ _ IH‚ÇÄ IH‚ÇÅ
  | lets _ _ IH‚ÇÄ IH‚ÇÅ
  | letsùïî _ _ IH‚ÇÄ IH‚ÇÅ
  | store‚ÇÅ _ _ IH‚ÇÄ IH‚ÇÅ
  | store‚ÇÇ _ _ IH‚ÇÄ IH‚ÇÅ =>
    simp at HIn
    cases HIn
    case inl HIn =>
      apply IH‚ÇÄ; apply HIn
    case inr HIn =>
      apply IH‚ÇÅ; apply HIn
